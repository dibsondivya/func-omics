---
title: "Group 2 report: Characterization of Alzheimer's disease"
subtitle: "A project for the course Statistics in Bioinformatics"
author: "Emil Johansson"
date: last-modified
date-format: "dddd [the] Do [of] MMMM YYYY"
format:
  html:
    theme: lumen
    title-block-banner: true
    smooth-scroll: true
    toc: true
    toc-depth: 4
    toc-location: right
    number-sections: true
    number-depth: 4
    code-fold: true
    code-tools: true
    code-copy: true
    code-overflow: wrap
    df-print: kable
    standalone: true
    fig-align: left
    figure:
      caption: "Figure {number}: {label}"
editor_options: 
  chunk_output_type: inline
execute:
  echo: true
  message: false
  warning: false
editor: 
  markdown: 
    wrap: 72
---

# Setup

```{r}
# Libraries we need
libs <- c(
  "tidyverse", "readxl", "limma", "ggrepel", "magrittr", "kableExtra",
  "patchwork", "DT", "tidymodels", "ggbeeswarm", "gt", "skimr", "GGally",
  "visdat", "corrr", "ggsignif", "vip", "themis", "keras", "xgboost", "kknn",
  "tensorflow", "xlsx", "HDAnalyzeR", "plotly", "umap", "uwot", "ggplotify",
  "cowplot", "ggvenn", "UpSetR", "ComplexUpset", "DESeq2", "pheatmap", "randomForest",
  "caret", "edgeR"
)

# Install missing libraries
installed_libs <- libs %in% rownames(installed.packages())
if (any(installed_libs == FALSE)) {
  install.packages(libs[!installed_libs])
}

# Load libraries
invisible(lapply(libs, library, character.only = TRUE))
```

# Random forest classification

## Prepare data

```{r}
# Load and prepare the data
data_raw <- read_tsv("data/voom_normalized.tsv")
data <- data_raw %>%
  distinct(GeneSymbol, .keep_all = TRUE) %>%
  dplyr::select(-GeneID) %>%
  filter(!is.na(GeneSymbol)) %>%
  column_to_rownames(var = "GeneSymbol") %>%
  mutate_all(~ ifelse(. < 0, 0, .)) %>%
  mutate_all(as.integer)

# Prepare metadata
metadata_raw <- read_xlsx("data/ad_metadata.xlsx")
metadata <- metadata_raw %>%
  mutate(Index = row_number()) %>%
  column_to_rownames(var = "Index") %>%
  dplyr::rename(sample = ID, disease = Disease) %>%
  mutate(individual = gsub("_raw", "", sample)) %>%
  dplyr::select(sample, individual, disease) %>%
  mutate(individual = factor(individual), disease = factor(disease))

# Ensure the data is in a matrix form with gene symbols as rownames
countData <- as.matrix(data)

# Prepare DESeqDataSet
dds <- DESeqDataSetFromMatrix(
  countData = countData,
  colData = metadata,
  design = ~ 0 + disease
)

# Estimate size factors
dds <- estimateSizeFactors(dds)

# Estimate gene-wise dispersions
dds <- estimateDispersionsGeneEst(dds)

# Directly use the gene-wise estimates
dispersions(dds) <- mcols(dds)$dispGeneEst

normCounts <- varianceStabilizingTransformation(dds, blind = FALSE)
```

```{r}
#Define model fitting procedure
#NB: you will also need the packages statmod and e1071 for this analysis
#New score function
rfSBF$score <- function(x, y){
sd(x) / mean(x)
}
#New filter function
rfSBF$filter <- function(score, x, y){
meanLog2CPM <- rowMeans(log2(cpm(data) + 1))
selection <- score > quantile(score, 0.9) & meanLog2CPM > 1
names(score) %in% names(score)[selection]
}
```

```{r}
#Create training set
trainingSet <- data.frame(t(assay(normCounts)))
#Train and validate decision tree (C5.0)
dtControl <- sbfControl(
  functions = rfSBF,
  method = "loocv",
  saveDetails = TRUE,
  verbose = FALSE)

dtModel <- sbf(
  trainingSet,
  metadata$disease,
  sbfControl = dtControl)

#Show model
#summary(dtModel$fit)
```

## Performance evaluation

```{r}
#Print confusion matrix from validation
confusionMatrix(dtModel$pred$predictions$pred, metadata$disease)
```

# Spearman correlation analysis

Loading the data for the correlaton analysis

```{r}
data <- read_tsv("data/voom_normalized.tsv")
de_results <- read_tsv("data/significant_genes.tsv")
metadata <- read_xlsx("data/ad_metadata.xlsx")
```

Performing Spearman correlation of the 63 upregulated genes on selected clinical variables of interest and comparing the correlation between Alzheimer's disease and control  samples.

```{r , fig.width=20, fig.height=10}
# Function to create correlation data and plot
create_correlation_plot <- function(data, metadata, gene_symbols, variable, title) {
  correlation_data <- data %>%
    filter(GeneSymbol %in% gene_symbols) %>%
    pivot_longer(cols = -GeneSymbol, names_to = "ID", values_to = "value") %>%
    right_join(metadata, by = "ID") %>%
    group_by(GeneSymbol, Disease) %>%
    summarise(correlation = cor(value, !!rlang::sym(variable), method = "spearman"), .groups = "drop") %>%
    ungroup()

  # Extract the order of genes based on their correlation in AD
  ad_correlations <- correlation_data %>%
    filter(Disease == "AD") %>%
    arrange(desc(correlation)) %>%
    pull(GeneSymbol)

  # Ensure that all GeneSymbols are included, even those not present in AD data
  full_gene_list <- unique(correlation_data$GeneSymbol)
  ad_order <- unique(c(ad_correlations, full_gene_list)) # This ensures all genes are included and in order

  # Set the levels of GeneSymbol according to their order in AD
  correlation_data$GeneSymbol <- factor(correlation_data$GeneSymbol, levels = ad_order)

  # Plot the heatmap with genes ordered by their correlation in AD
  heatmap_plot <- ggplot(correlation_data, aes(x = Disease, y = GeneSymbol, fill = correlation)) +
    geom_tile() +
    scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(fill = "Correlation", y = "Gene (ordered by AD correlation)", x = "Disease", title = title)

  return(heatmap_plot)
}

# Variables of interest
variables_of_interest <- c("Age", "PMI", "Mean_plaque", "CDR")

# Plot list
plot_list <- list()

# Loop over variables and create plots
for (variable in variables_of_interest) {
  plot_list[[variable]] <- create_correlation_plot(data, metadata, de_results$GeneSymbol, variable, paste("Correlation with", variable))
}

# Combine plots
combined_plot <- wrap_plots(plot_list, nrow = 1)

# Print the combined plot
print(combined_plot)
```

# Session info

```{r}
sessionInfo()
```
